<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Simple Linear Classification</title>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<style type="text/css">
<!--
body { background-color:#ededed; font:norm2al 12px/18px Arial, Helvetica, sans-serif; }
h1 { display:block; width:600px; margin:20px auto; paddVing-bottom:20px; font:norm2al 24px/30px Georgia, "Times New Roman", Times, serif; color:#333; text-shadow: 1px 2px 3px #ccc; border-bottom:1px solid #cbcbcb; }
#container { width:600px; margin:0 auto; }
#myCanvas { background:#fff; border:1px solid #cbcbcb; }
#nav { display:block; width:100%; text-align:center; }
#nav li { display:block; font-weight:bold; line-height:21px; text-shadow:1px 1px 1px #fff; width:100px; height:21px; paddVing:5px; margin:0 10px; background:#e0e0e0; border:1px solid #ccc; -moz-border-radius:4px;-webkit-border-radius:4px; border-radius:4px; float:left; }
#nav li a { color:#000; display:block; text-decoration:none; width:100%; height:100%; }
-->
</style>
</head>
<script>

//-----------------------simple graphing code

var zoom = 600*.9;
var center_x = 30;
var center_y = 600-30;

function ViewportX(x) { return (x*zoom+center_x); }
function ViewportY(y) { return (-y*zoom+center_y); }
function InvViewportX(vx) { return ((vx-center_x)/zoom); }
function InvViewportY(vy) { return (-(vy-center_y)/zoom); }

function moveTo(context, x,y) { context.moveTo(ViewportX(x),ViewportY(y)); }
function lineTo(context, x,y) { context.lineTo(ViewportX(x),ViewportY(y)); }
function fillText(context, str, x,y ) { context.fillText(str,ViewportX(x),ViewportY(y)); }

function DrawAxis(context)
{
    context.beginPath();
    context.strokeStyle="#000000";
    moveTo(context, -100,0);      
    lineTo(context,  100,0);      
    moveTo(context, 0, -100);      
    lineTo(context, 0, 100);      
    context.closePath();
    context.stroke();

    for(var i=-30;i<30;i++)
    {
        context.font="15px ti92pluspc";
        fillText(context, i,i,0);
        fillText(context, i,0,i);
    }
}

function DrawLine(context, x1,y1,x2,y2)
{
    context.beginPath();
    moveTo(context, x1,y1);      
    lineTo(context, x2,y2);      
    context.closePath();
    context.stroke();
}

//----------------------Point distribution generation and drawing

var axis_a;
var axis_b;

var points = []
var target = []

function LinearF(x,y)
{
    return (axis_a*x-y+axis_b)>0?1:0;
}

function RandomizeLinearF()
{
    var px = Math.random()
    var py = Math.random()

    axis_a = (py-.5)/(px-.5);
    axis_b = (1-axis_a)*.5;
       
    points = []
    target = []
}

//------------------ Compute and draw a set

function GenerateDataSet(func)
{
    for(var i=0;i<20;i++)
    {
        var x = Math.random()
        var y = Math.random()
        
        points.push([x, y])
        target.push(func(x, y))
    }
}

function DrawF(context)
{
    x1 = -10; y1 = axis_a*x1+axis_b
    x2 =  10; y2 = axis_a*x2+axis_b
    DrawLine(context, x1,y1,x2,y2)
}

function DrawPoints(context, radius)
{
    for(var i=0;i<points.length;i++)
    {
        var x = points[i][0];
        var y = points[i][1];
        if (target[i]==0)
        {
            context.beginPath();
            context.moveTo((ViewportX(x) - radius), ViewportX(y));      
            context.lineTo((ViewportX(x) + radius), ViewportX(y));           
            context.moveTo(ViewportX(x), ViewportX(y) - radius);      
            context.lineTo(ViewportX(x), ViewportX(y) + radius);           
            context.closePath();
            context.stroke();
        }
        else
        {
            context.beginPath();
            context.arc(ViewportX(x), ViewportX(y), radius, 0 ,  2 * Math.PI);
            context.stroke();
        }
    }
}

//----------------------network

function Act(x)
{
    return 1.0/(1.0+Math.exp(-5*x));
}

function DerAct(x)
{
    return Act(x)*(1-Act(x));
}

function net(w1,w2, w3, i1,i2)
{
    return w1*i1+w2*i2+w3;
}

// g(a,b,c) = ax+by+c
function dnetdw1(x,y) { return x; }
function dnetdw2(x,y) { return y; }
function dnetdw3(x,y) { return 1; }

var w1=0;
var w2=0;
var w3=0;

function DrawDecisionBoundary()
{    
    var canvasData = context.getImageData(0, 0, 600, 600);
    
    for(var y=0;y<600;y++)
    {
        for(var x=0;x<600;x++)
        {
            var index = (x + y * 600) * 4;
           
            xx = InvViewportX(x);
            yy = InvViewportX(y);
            
            v = (Act(net(w1,w2,w3, xx,yy)))>.5?255:0;

            canvasData.data[index + 0] = v;
            canvasData.data[index + 1] = 255-v;
            canvasData.data[index + 2] = 0;
            canvasData.data[index + 3] = 128;
        }
    }
    context.putImageData(canvasData, 0, 0);    
}

//------------------------learning loop

var epoch = 0;

function iterate()
{    
    context.beginPath();
    context.strokeStyle="#ff0000";

    var learningRate=.1;
    for(var i=0;i<100;i++)
    {
        epoch++;

        var totalErr = 0;
    
        for(var pindex=0;pindex<points.length;pindex++)
        {   
            var p = points[pindex];
            var i1 = p[0];
            var i2 = p[1];

            //compute real value
            t = target[pindex]
            
            // e = ( s(net(w1,w2,i1,i2))-t)^2
            n = net(w1,w2,w3, i1,i2)
            o = Act(n);
            
            //compute mean square error
            totalErr += (o-t)*(o-t);
            
            // de = 2*(s(net)-t) * s'(net) * (dg/da, dg/db)          
            de = 2*(o-t) * DerAct(n);

            //update weights with dE
            w1 += -learningRate * de * dnetdw1(i1,i2);
            w2 += -learningRate * de * dnetdw2(i1,i2);
            w3 += -learningRate * de * dnetdw3(i1,i2);
        }
        
        // if g is close to t then restart
        if (Math.abs(totalErr)<.1)
        {
            epoch = 0;
            w1 = 2*Math.random()-1;
            w2 = 2*Math.random()-1;
            w3 = 2*Math.random()-1;
            
            RandomizeLinearF()
            GenerateDataSet(LinearF)
            
            break;
        }
    }
    context.closePath();
    context.stroke();        
    
    DrawDecisionBoundary();
    context.strokeStyle="#000000";    

    DrawAxis(context)
    
    DrawPoints(context,10);

    //draw the plane used to generate the points
    //DrawF(context);

    document.getElementById("text").innerHTML = "<br>Epoch:"+ epoch + "<br>Error: "  + Math.abs(totalErr) + "<br>Coeff a: "  + w1 + "<br>Coeff b: " + w2 + "<br>Coeff c: " + w3 + "<br>";
}

function init()
{
    var myCanvas = document.getElementById("myCanvas");
    context = myCanvas.getContext('2d');
    context.clearRect(0,0,600,600);

    RandomizeLinearF()
    GenerateDataSet(LinearF)
    
    setInterval(iterate,10); 
}
</script>


<body onload="init()">
<h1>AI, 2x1 Classifier</h1>
<div id="container">
	
<canvas id="myCanvas" width="600" height="600"></canvas>

<div id="text"></div>

<h2>Intro</h2>

This a demo classifies 2 types of points. The points can be separated by a plane.  We are training a neuron to find the plane that divides the set.
</br>
</br>
Note that without a bias we'd only be able to come up with planes that pass by the origin.  
</br>
</br>
<h2>Contact/Questions:</h2>
 &lt;my_github_account_username&gt;$@gmail.com$.
</br>
</br>
</div>
</body>
</html>
